# operating-system

> 운영체제
> - 컴퓨터 시스템을 운영하고 소프트웨어적으로 구현하는 것
> - h/w device 제어할 수 있는 운영체제(window, linux, mac) 존재함
> - 이러한 운영체제를 통해 여러 app 들은 h/w 서비스를 받을 수 있게 운영체제가 인터페이스를 제공
> - user 가 필요로 하는 input/output 에 대한 것을 운영체제가 관리


> 실행단위 
> - cpu core에서 실행하는 하나의 단위로 프로세스와 스레드를 포괄하는 개념

> 프로세스
> - 하나의 스레드만 가지고 있는 단일 스레드 프로세스

> 동시성
> - 한 순간에 여러가지 일이 아니라, 짧은 전환으로 여러가지 일을 동시에 처리하는 것 처럼 보이는 것


> 피자 집에 갔는데, 피자 레시피(프로그램의 구현 코드 파일)가 적힌 종이를 줌 (실행시키기 전까지는 그냥 코드 파일일 뿐), 실행이 되어서 사용할 수 있는, 즉 먹을 수 있는 피자가 되어야 함 (피자를 만드는 과정이 프로세스)
> 프로그램이 프로세스가 되면서 어떤일이 일어날까?
> 프로세스가 필요로 하는 재료들이 메모리에 올라가야 함. 
> 1. (실행명령을 포함하는 코드영역, static global 변수를 선언하는 데이터영역, 동적 메모리를 위한 힙영역, 지역변수, 반환값 등을 담는 일시적인 데이터를 담는 스택영역) 얘네가 메모리를 확보함
> 2. process control block, 해당 프로세스에 대한 정보를 담고 있는 블럭 (대기 상태 큐의 포인터, pid, process state)

> 원래, 하나의 프로세스가 실행되기 위해서 cpu를 점유하고 있으면 다른 프로세스는 실행상태에 있을 수 없음
> 그래서 다수의 프로세스를 동시에 실행하기 위해 다수의 프로세스를 시분할로(짧은 텀을 반복, 전환)하여 실행시킴
> == context switching

> 이러한, 컨텍스트 스위칭보다 더 가벼운 경량화 된 프로세스 버전인 스레드
> 하나의 프로세스 안에 다수의 스레드는 공유되는 자원이 있기 때문
> 프로세스의 메모리 구조에서 코드, 데이터, 힙 영역을 공통된 자원으로 사용함
> 각 스레드는 스택부분만 개인적으로 가지고 있어 매우 효율적임
> 이전처럼 컨텍스트 스위칭이 일어날 때 캐싱 적중률이 올라감(모조리 다 빼고 다시 다 넣을 필요가 없다는 것)

> 멀티프로세스 , 멀티스레드는 한 어플리케이션에 대한 처리방식임
> 단순히, 여러가지의 프로그램을 띄워놓은 것을 멀티프로세스라 한다면 멀티스레드랑 비교하여 이야기하기 힘듦

> 두가지의 처리방식이 있다고 생각하겠음
> 여러 사용자가 로그인을 요청하는 상황임
> 하나의 프로세스의 하나의 요청을 처리하기 때문에 동시에 처리할 수 없음
> 그래서 부모프로세스가 자식 프로세스를 fork()로 만들어서 일을 처리하도록 함
> 이때, 자식 프로세스는 부모 프로세스와 별개의 메모리 영역을 확보함

> 프로세스 내에서 분리해서 여러 스레드로 나뉘어서 실행단위가 나뉘어지면 이게 멀티스레드가 되는것 (한 어플리케이션에 대한 작업 단위가 나눠질때가 많음)
> 예를 들어, 테스트를 돌리며 소스 코드를 수정 (이때 각각의 쓰레드가 그 작업을 담당하는 것)

> 차이점은 프로세스는 독립적이기 때문에 IPC를 통해서 통신해야 함(같은 작업을 두명이 두개의 다른 회의실에서 진행하다 논의할 일이 생기면 밖으로 나와서 논의를 하고 다시 들어가는 것)
> 자원이 소모적이고 메모리를 더 차지함
> 컨텍스트 스위칭 가격도 비쌈
> 하지만, 개별 독립적이기 때문에 동기화 작업에 신경을 덜 써도 됨

> 쓰레드는 공유자원이 많으므로 긴밀하게 연결되어 있음, 그만큼 동기화도 신경써야지 공유된 자원으로 메모리가 효율적이고 통신 비용이 절감됨
> (두명이 하나의 회의실에서 일을 처리하고 있기 때문에 그냥 말을 하면서 일을 처리 할 수 있음)₩    
> 컨텍스트 스위칭 비용도 적음

> 긴밀하게 연결되어 있기 때문에 하나의 스레드, 하나의 탭에 문제가 생기면 전체 프로세스에 영향이 감
> 구글 크롬은 멀티프로세스를 이용하고 있기 때문에 멀티탭 간의 영향을 덜 받음

> mulit-core
> 조금 더 하드웨어의 측면에 가까움(동시성, 병렬처리)
> 싱글 코어를 가진 cpu가 실행 단위를 처리할 때는 동시에 여러가지를 실행하기 위해 빠른 텀으로 전환이 됨 (== 동시성)
> 여러 실행 단위를 번갈아 실행하면서 동시에 일어나는 것 처럼 보이게 하는것 (== 동시성)
> 짧은 순간에 cpu의 시간을 분할해서 동시에 하는 것처럼 보이게 하는 것 (== 동시성)

> 멀티 코어는 물리적으로 여러 코어를 사용하여 다수의 실행 단위를 한 순간에 동시에 처리할 수 있게 해준 것(== 병렬처리)
> 다수의 프로세서로 여러가지 일을 각 코어에서 진행 하는 것


> 리눅스에서 process, thread
> 리눅스 커널에서는 프로세스와 스레드를 동일하게 봄
> 사용자 스레드당 커널 스레드 하나가 매칭되어 있는 일대일 관계
> 각각의 쓰레디가 하나의 프로세스다라고 말할 수 있음 (하나의 프로세스의 생성된 스레드는 모두 같은 pid를 가지고 있음)
> 하지만, tgid : 스레드 그룹 아이디, tid : 스레드 아이디
> 사용자 레벨에서 본다면 스레드 그룹 아이디가 pid로 보여지고, 커널 입장에서는 tid가 pid로 인식 됨 (관점을 다르게 해서 이해해야 함.)


> 1. 프로세스는 프로그램이 실행된 것
> 2. 스레드는 한 프로세스 내에서 나눠진 하나 이상의 실행 단위이다.
> 3. 한 어플리케이션에 대한 작업을 동시에 하기 위해서는 2가지 처리 방식(멀티 프로세스, 멀티 스레드)이 있다.
> 4. 동시에 실행되는 것 처럼 보이기 위해서 실행 단위는 시분할로 cpu를 점유하여 context switching을 한다.
> 5. 멀티 프로세스는 독립적인 메모리를 가지고 있지만 멀티 스레드는 자원을 공유한다. 그것에 따른 각각의 장단점이 있다.
> 6. 멀티 코어는 하드웨어  측면에서 실행 단위를 병렬적으로 처리할 수 있도록 여러 프로세서가 있는 것이다.
